*****





\subsection*{File.Close

Closes an open file.

\paragraph{Input}

\item kernel.args.file.close.stream contains the stream ID of the file.

\paragraph{Output}

\item Carry cleared on success.
\item Carry set on error (kernel is out of event objects).

\paragraph{Events}

\item The kernel will always queue an event.file.CLOSED, even if an I/O error occurs during the close.  The event will contain the stream id in \verb+event.file.stream+ and the the user's cookie in \verb+event.file.cookie+.


\paragraph{Notes}

\item The kernel will always queue an event.file.CLOSED, even if an I/O error occurs during the close.
\item Upon a successful call to File.Close, no further operations should be attempted on the given stream (the stream ID will be returned to the kernel's free pool for use by subsequent file operations).

\subsection*{File.Rename

Renames a file.  The file should not be in use.

\paragraph{Input}

\item \verb+kernel.args.file.rename.drive+ contains the drive ID (0 = SD, 1 = IEC #8, 2 = IEC #9)
\item \verb+kernel.args.file.rename.cookie+ contains a user supplied cookie for matching the completed event.
\item \verb+kernel.args.file.rename.old+ points to a file path containing the name of the file to rename.
\item \verb+kernel.args.file.rename.old_len+ contains the length of the path above.
\item \verb+kernel.args.file.rename.new+ points to the new name for the file (**NOT+ a new _path_!)
\item \verb+kernel.args.file.rename.new_len+ contains the length of the new name above.

\paragraph{Output}

\item Carry cleared on success.
\item Carry set on error (device not found; kernel out of events).

\paragraph{Events}

\item On successful completion, the kernel will queue a \verb+file.RENAMED+ event.
\item On failure, the kernel will queue a \verb+file.ERROR+ event.
\item In either case, \verb+event.file.cookie+ will contain the cookie supplied above.

\paragraph{Notes}

\item Rename semantics are up to the device (in the case of IEC) or the fat32.s driver (in the case of Fat32).  The kernel doesn't even look at the arguments to see if they are sane.  This means you may or may not be able to, say, change the case of letters in a filename with a single rename call; you may need to rename to a temp name, and then rename to the case-corrected name.

\item Similarly, the kernel doesn't actually check if the file is in-use or not.  Whether this matters is up to the device or file-system driver; treat the above statement that the file should not be in use as a strong recommendation. 

\item Rename is \verb+NOT+ a 'move'.  You can only rename a file in place.  If you want to move it, you will need to copy and then delete.

\subsection*{File.Delete

Deletes a file.  The file should not be in use.

\paragraph{Input}

\item \verb+kernel.args.file.delete.drive+ contains the drive ID (0 = SD, 1 = IEC #8, 2 = IEC #9)
\item \verb+kernel.args.file.delete.cookie+ contains a user supplied cookie for matching the completed event.
\item \verb+kernel.args.file.delete.fname+ points to a file path containing the name of the file to delete.
\item \verb+kernel.args.file.delete.fname_len+ contains the length of the path above.

\paragraph{Output}

\item Carry cleared on success.
\item Carry set on error (device not found; kernel out of events).

\paragraph{Events}

\item On successful completion, the kernel will queue a \verb+file.DELETED+ event.
\item On failure, the kernel will queue a \verb+file.ERROR+ event.
\item In either case, \verb+event.file.cookie+ will contain the cookie supplied above.

\paragraph{Notes}

\item Case matching is up to the device (IEC) or the file-system driver (fat32.s).
\item Delete semantics are up to the device (in the case of IEC) or the fat32.s driver (in the case of Fat32).  The kernel doesn't even look at the path to see if it is sane. 

\item Similarly, the kernel doesn't actually check if the file is in-use or not.  Whether this matters is up to the device or file-system driver; treat the above statement that the file should not be in use as a strong recommendation. 

#\section*{Directory Calls

\subsection*{Directory.Open

Opens a directory for reading.

\paragraph{Input}

\item \verb+kernel.args.directory.open.drive+ contains the device id (0 = SD, 1 = IEC #8, 2 = IEC #9).
\item \verb+kernel.args.directory.open.path+ points to a buffer containing the path.
\item \verb+kernel.args.directory.open.lan_len+ contains the length of the path above.  May be zero for the root directory.
\item \verb+kernel.args.directory.open.cookie+ contains a user-supplied cookie for matching the completed event.

\paragraph{Output}

\item Carry cleared on success; \verb+A+ contains the stream id.
\item Carry set on error (device not found, kernel out of event or stream objects).

\paragraph{Events}

\item On successful completion, the kernel will queue an \verb+event.directory.OPENED+ event.
\item On error, the kernel will queue an \verb+event.directory.ERROR+ event.
\item In either case, \verb+event.directory.cookie+ will contain the above cookie.

\paragraph{Notes}

\item The IEC protocol only supports reading one directory per device at a time.  The kernel does not, however, prevent you from trying.  Consider yourself warned.

\subsection*{Directory.Read

Reads the next directory element (volume name entry, file entry, bytes-free entry).

\paragraph{Input} 

\item \verb+kernel.args.directory.stream+ contains the stream id.

\paragraph{Output}

\item Carry cleared on success.
\item Carry set on error (EOF has occurred or the kernel is out of event objects).

\paragraph{Events}

\item The first read will generally queue an \verb+event.directory.VOLUME+ event.  \verb+event.directory.volume.len+ will contain the length of the volume name. Call ReadData to retrieve the volume name.

\item Subsequent reads will generally queue an \verb+event.directory.FILE+ event.  \verb+event.directory.file.len+ will contain the length of the filename.  \verb+ReadData+ will retrieve the file name; \verb+ReadExt+ will retrieve the meta-data (presently just the sector count).

\item The last read before EOF will generally queue an \verb+event.directory.FREE+ event.  \verb+event.directory.free.free+ will contain the number of free sectors on the device.

\item The final read will queue an \verb+event.directory.EOF+ event.

\item Should an error occur while reading the directory, the kernel will queue an \verb+event.directory.ERROR+ event.

\paragraph{Notes}

\item The IEC protocol does not support multiple concurrent directory reads.
\item Attempting to open files while reading an IEC directory have been known to result in directory read errors (cc65 errata). 
\item SD2IEC devices cap the sectors-free report at 65535 sectors.

\subsection*{Directory.Close


\paragraph{Input} 

\item \verb+kernel.args.directory.stream+ contains the stream id.

\paragraph{Output}

\item Carry cleared on success.
\item Carry set on error (kernel is out of event objects).

\paragraph{Events}

\item The kernel will always queue an \verb+event.directory.CLOSED+ event, even if an error should occur.

\paragraph{Notes}

\item Do not attempt to make further calls against the same stream id after calling Directory.Close -- the stream will be returned to the kernel for allocation to subsequent file operations.

#\section*{Network Calls - Generic

\subsection*{Network.Match

Determines if the packet in the current event belongs to the provided socket.


\paragraph{Input}

\item \verb+kernel.args.net.socket+ points to either a TCP or UDP socket.

\paragraph{Output}

\item Carry cleared if the socket matches the packet.
\item Carry set if the socket does not match the packet.

#\section*{Network Calls - UDP

\subsection*{Network.UDP.Init

Initializes a UDP socket in the user's address space.

\paragraph{Input}

\item \verb+kernel.args.net.socket+ points to a 32 byte 
UDP socket structure.
\item \verb+kernel.args.net.dest_ip+ contains the destination address.
\item \verb+kernel.args.net.src_port+ contains the desired source port.
\item \verb+kernel.args.net.dest_port+ contains the desired destination port.

\paragraph{Output}

\item Carry clear (always succeeds).

\paragraph{Events}

\item None

\paragraph{Notes}

\item Opening a UDP socket _does not_ create a packet filter for the particular socket.  Instead, ALL UDP packets received by the kernel are queued as events; it is up to the user program to accept or ignore each in turn.

\subsection*{Network.UDP.Send

Writes data to a UDP socket.

\paragraph{Input}

\item \verb+kernel.args.net.socket+ points to a 32 byte 
UDP socket structure.
\item \verb+kernel.args.net.buf+ points to the send buffer.
\item \verb+kernel.args.net.buf_len+ contains the length of the buffer (0 = 256, but see the notes section)

\paragraph{Output}

\item Carry cleared on success.
\item Carry set on error (kernel is out of packet buffers).

\paragraph{Events}

\item None

\paragraph{Notes}

\item By design, the kernel limits all network packets to 256 bytes.  This means the maximum payload for a single UDP packet is 228 bytes.
\item _Bug_: the kernel doesn't currently stop you from trying to send more than 228 bytes.  Attempts to do so will result in corrupt packets.

\subsection*{Network.UDP.Recv

Reads the UDP payload from an \verb+event.network.UDP+ event.

\paragraph{Input}

\item \verb+kernel.args.net.buf+ points to the receive buffer.
\item \verb+kernel.args.net.buflen+ contains the size of the receive buffer.

\paragraph{Output}

\item Carry cleared on success; \verb+kernel.args.net.accepted+ contains the number of bytes copied from the event (0 = 0).
\item Carry set on failure (event is not a network.UDP event).

\paragraph{Notes}

\item The full packet may be read into the user's address space by calling \verb+kernel.ReadData+.


#\section*{Network Calls - TCP

\subsection*{Network.TCP.Open

Initializes a TCP socket in the user's address space.

\paragraph{Input}

\item \verb+kernel.args.net.socket+ points to a 256 byte 
TCP socket structure (includes a re-transmission queue).
\item \verb+kernel.args.net.dest_ip+ contains the destination address.
\item \verb+kernel.args.net.dest_port+ contains the desired destination port.

\paragraph{Output}

\item Carry clear (always succeeds).

\paragraph{Events}

\item None

\paragraph{Notes}

\item Opening a TCP socket _does not_ create a packet filter for the particular socket.  Instead, ALL TCP packets received by the kernel are queued as events; it is up to the user program to accept or reject each in turn; see \verb+Network.Match+.

\subsection*{Network.TCP.Accept

Accepts a new connection from the outside world.

\paragraph{Notes}

\item _Not yet implemented._

\subsection*{Network.TCP.Reject

Rejects a connection from the outside world.  May also be used to forcibly abort an existing connection.

\paragraph{Notes}

\item _Not yet implemented._


\subsection*{Network.TCP.Send

Writes data to a TCP socket.

\paragraph{Input}

\item \verb+kernel.args.net.socket+ points to the socket.
\item \verb+kernel.args.net.buf+ points to the send buffer.
\item \verb+kernel.args.net.buf_len+ contains the length of the buffer (0 = 0; may be used to force re-transmission).

\paragraph{Output}

\item Carry cleared on success; \verb+kernel.args.net.accepted+ contains the number of byte accepted.
\item Carry set on error (socket not yet open, user has closed this side of the socket, kernel is out of packet buffers).

\paragraph{Events}

\item None

\paragraph{Notes}

\item The socket presently contains a 128 byte transmit queue.  This queue is forwarded by both \verb+Network.TCP.Send+ and by \verb+Network.TCP.Recv+.  The remote host must ACK the bytes in the transmit queue before more bytes become available in the queue.

\subsection*{Network.TCP.Recv

\item Reads the TCP payload from an \verb+event.network.TCP+ event.
\item ACKs valid packets from the remote host.
\item Maintains the state of the socket. 

\paragraph{Input}

\item \verb+kernel.args.net.socket+ points to the socket.
\item \verb+kernel.args.net.buf+ points to the receive buffer.
\item \verb+kernel.args.net.buflen+ contains the size of the receive buffer.

\paragraph{Output}

\item Carry cleared on success; \verb+kernel.args.net.accepted+ contains the number of bytes copied from the event (0 = 0). \verb+A+ contains the socket state.
\item Carry set on failure (event is not a network.TCP event).

\paragraph{Notes}

\item The full packet may be read into the user's address space by calling \verb+kernel.ReadData+.

\subsection*{Network.TCP.Close

Tells the remote host that no more data will be sent from this side of the socket.  The remote host is, however, free to continue sending until it issues a close.

\paragraph{Input}

\item \verb+kernel.args.net.socket+ points to the socket.

\paragraph{Output}

\item Carry cleared on success.
\item Carry set on failure (kernel is out of buffers).

#\section*{Display Calls

\subsection*{Display.Reset

Resets the display resolution and colors and disables the mouse and cursor.  Does NOT reset the font.

\paragraph{Input}

\item None

\paragraph{Output}

\item None

\paragraph{Notes}

\item In the future, the kernel should include support for re-initializing the default fonts.

\subsection*{Display.GetSize

Returns the size of the current text display.

\paragraph{Input}

\item None

\paragraph{Output}

\item \verb+kernel.args.display.x+ contains the horizontal size.
\item \verb+kernel.args.display.y+ contains the vertical size.

\subsection*{Display.DrawRow

Copies the user provided text buffer to the screen (from left to right) starting at the provided coordinates and using the provided color buffer.

\paragraph{Input}

\item \verb+kernel.args.display.x+ contains the starting x coordinate.
\item \verb+kernel.args.display.y+ contains the starting y coordinate.
\item \verb+kernel.args.display.text+ points to the text data.
\item \verb+kernel.args.display.color+ points to the color data.
\item \verb+kernel.args.buflen+ contains the length of the buffer.

\paragraph{Output}

\item Carry cleared on success.
\item Carry set on error (x/y outside of the screen)

\paragraph{Notes}
\item Probably isn't yet checking the coordinate bounds or clipping.

\subsection*{Display.DrawColumn

Copies the user provided text buffer to the screen (from top to bottom) starting at the provided coordinates and using the provided color buffer.

\paragraph{Input}

\item \verb+kernel.args.display.x+ contains the starting x coordinate.
\item \verb+kernel.args.display.y+ contains the starting y coordinate.
\item \verb+kernel.args.display.text+ points to the text data.
\item \verb+kernel.args.display.color+ points to the color data.
\item \verb+kernel.args.buflen+ contains the length of the buffer.

\paragraph{Output}

\item Carry cleared on success.
\item Carry set on error (x/y outside of the screen)

\paragraph{Notes}

\item _Not yet implemented._

